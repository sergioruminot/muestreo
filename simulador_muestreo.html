<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simulador de Muestreo — Teorema Central del Límite</title>
  <!-- React 18 + Babel (para JSX en un solo archivo HTML) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- SheetJS para exportar Excel -->
  <script src="https://cdn.sheetjs.com/xlsx-0.20.1/package/dist/xlsx.full.min.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji'; background:#f5f5f5; padding: 20px; }
    .container { max-width: 1400px; margin: 0 auto; background: #fff; padding: 28px; border-radius: 14px; box-shadow: 0 8px 28px rgba(0,0,0,.08); }
    h1 { text-align:center; font-weight:800; letter-spacing:.2px; color:#111827; margin-bottom: 8px; }
    .sub { text-align:center; color:#6b7280; margin-bottom: 14px; font-size: 14px; }
    .grid { display:grid; grid-template-columns: 360px 1fr; gap: 26px; min-height: 720px; }
    .card { background:#fff; border:1px solid #e5e7eb; border-radius: 12px; padding: 18px; box-shadow: 0 2px 10px rgba(0,0,0,.04); }
    .controls { background:#fafafa; }
    .card h2 { font-size: 16px; color:#111827; margin-bottom: 12px; }
    .row { margin-bottom: 14px; }
    label { display:block; font-weight:700; font-size: 12px; color:#374151; margin-bottom: 6px; }
    .inline { display:flex; align-items:center; gap:8px; }
    .indent { margin-left: 28px; }
    select, input[type="number"], input[type="text"] { width: 100%; padding: 10px 12px; border-radius: 10px; border:2px solid #e5e7eb; background:#fff; font-size: 14px; }
    select:focus, input:focus { outline:none; border-color:#2563eb; }
    input[type="checkbox"]{ transform: translateY(1px); }
    .two-cols { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .btn { width:100%; padding: 12px; border:none; border-radius: 12px; font-weight: 800; cursor:pointer; transition: .2s; margin-bottom: 10px; letter-spacing:.2px; }
    .btn.primary { background:#2563eb; color:#fff; }
    .btn.primary:hover { background:#1d4ed8; }
    .btn.success { background:#16a34a; color:#fff; }
    .btn.success:hover { background:#15803d; }
    .btn.danger { background:#dc2626; color:#fff; }
    .btn.danger:hover { background:#b91c1c; }
    .btn.excel { background:#10b981; color:#fff; }
    .btn.excel:hover { background:#059669; }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .stats { background:#eef2ff; border-left:4px solid #4f46e5; padding: 12px; border-radius: 10px; margin: 10px 0 14px; }
    .stats h3 { font-size: 12px; color:#4338ca; margin-bottom: 6px; }
    .stat { display:flex; justify-content:space-between; font-size: 13px; margin: 2px 0; color:#1f2937; }
    .charts { display:grid; gap:18px; }
    .charts.three-charts { grid-template-rows: 1fr 1fr 1fr; }
    .charts.two-charts { grid-template-rows: 1fr 1fr; }
    .chart-card { border:1px solid #e5e7eb; border-radius: 12px; padding: 12px; background:#fff; }
    .chart-card h3 { text-align:center; font-size: 14px; color:#374151; margin-bottom: 8px; }
    .chart-wrap { position:relative; height: 280px; }
    .info { background:#fef3c7; color:#92400e; border:1px solid #f59e0b; padding:10px; border-radius:10px; font-size: 12px; text-align:center; }
    .progress { background:#dcfce7; color:#166534; border:1px solid #16a34a; border-radius:10px; padding:8px; font-size: 12px; text-align:center; margin: 8px 0; display:none; }
    .tests { margin-top: 10px; font-size: 12px; color:#374151; }
    .tests code { background:#f3f4f6; padding: 2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // ---------------- PRNG con semilla -----------------
    function strToSeed(str){
      if(!str || str.length===0) return 0x9E3779B9; // constante por defecto (reproducible en todas las máquinas)
      let h = 1779033703 ^ str.length;
      for(let i=0;i<str.length;i++){
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return h >>> 0;
    }
    function mulberry32(a){
      let t = a >>> 0;
      return function(){
        t += 0x6D2B79F5; t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    // Utilidades ---------------------------------------------------------------
    const mean = arr => {
      if(!arr || arr.length === 0) return 0;
      return arr.reduce((a,b)=>a+b,0)/arr.length;
    };
    const popVar = (arr, m) => {
      if(!arr || arr.length === 0) return 0;
      return arr.reduce((s,x)=>s+(x-m)**2,0)/arr.length;
    };
    const popSd = (arr) => {
      if(!arr || arr.length === 0) return 0;
      return Math.sqrt(popVar(arr, mean(arr)));
    };

    const clampNat = (x, min=1) => {
      const v = Math.floor(Number(x));
      return (Number.isFinite(v) && v >= min) ? v : min;
    };
    const safeNum = (x, fallback) => {
      const v = Number(x);
      return Number.isFinite(v) ? v : fallback;
    };

    function makeHistogram(data, bins=30){
      const min = Math.min(...data), max = Math.max(...data);
      
      // Caso especial: todos los valores son iguales (o muy cercanos)
      if(Math.abs(max - min) < 1e-10){
        const value = min;
        const counts = [data.length];
        const labels = [value];
        const edges = [value - 0.5, value + 0.5];
        return {labels, counts, edges, width: 1};
      }
      
      const width = (max-min)/bins || 1;
      const edges = Array.from({length: bins+1}, (_,i)=>min+i*width);
      const counts = new Array(bins).fill(0);
      for(const v of data){
        let k = Math.floor((v-min)/width);
        if(k>=bins) k=bins-1;
        if(k<0 || !Number.isFinite(k)) k=0;
        counts[k]++;
      }
      const labels = edges.slice(0,-1).map((e)=> (e+width/2));
      return {labels, counts, edges, width};
    }

    // Normal CDF ---------------------------------------------------------------
    function erf(x){
      const sign = x < 0 ? -1 : 1;
      x = Math.abs(x);
      const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
      const t = 1/(1+p*x);
      const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
      return sign*y;
    }
    const Phi = z => 0.5*(1+erf(z/Math.SQRT2));
    const normalBinMass = (a,b,mu,sd) => {
      if(sd <= 0 || !Number.isFinite(sd)) return 0;
      return Phi((b-mu)/sd) - Phi((a-mu)/sd);
    };

    // Generadores (seed-aware) -------------------------------------------------
    function rndNormal(mean=50, sd=2, rng=Math.random){
      const u1 = Math.max(rng(), 1e-16);
      const u2 = Math.max(rng(), 1e-16);
      const z = Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2);
      return mean + sd*z;
    }
    function rndUniform(a=30,b=70, rng=Math.random){ return a + rng()*(b-a); }
    function rndExpoShift(lambda=0.1, shift=40, rng=Math.random){ return -Math.log(1 - Math.min(rng(), 1-1e-16))/lambda + shift; }
    function randChiSquare(df, rng=Math.random){
      df = Math.max(1, Math.floor(df));
      let s = 0;
      for(let i=0;i<df;i++){ const z = rndNormal(0,1, rng); s += z*z; }
      return s;
    }
    function rndT(df, rng=Math.random){
      const z = rndNormal(0,1, rng);
      const chi = randChiSquare(df, rng);
      return z / Math.sqrt(chi/df);
    }

    function sanitizeParams(type, params){
      // Asegurar números finitos y dominios válidos
      const out = {...params};
      if(type==='normal'){
        out.muN = safeNum(params.muN, 0);
        out.sdN = Math.max(safeNum(params.sdN, 1), 0.0001);
      } else if(type==='uniforme'){
        out.uniA = safeNum(params.uniA, 0);
        out.uniB = safeNum(params.uniB, 100);
        if(out.uniB <= out.uniA) out.uniB = out.uniA + 1;
      } else if(type==='exponencial'){
        out.expLambda = Math.max(safeNum(params.expLambda, 0.1), 0.0001);
        out.expShift = safeNum(params.expShift, 0);
      } else if(type==='tstudent'){
        out.dfT = clampNat(params.dfT, 1);
        out.tMu = safeNum(params.tMu, 0);
        out.tScale = Math.max(safeNum(params.tScale, 1), 0.0001);
      } else if(type==='chisq'){
        out.dfChi = clampNat(params.dfChi, 1);
        out.chiScale = Math.max(safeNum(params.chiScale, 1), 0.0001);
        out.chiShift = safeNum(params.chiShift, 0);
      }
      return out;
    }

    function generatePop(N, type, params){
      const clean = sanitizeParams(type, params);
      const seedVal = strToSeed(params.seed);
      const rng = mulberry32(seedVal);
      const data = [];
      for(let i=0;i<N;i++){
        let val;
        if(type==='normal'){
          val = rndNormal(clean.muN, clean.sdN, rng);
        } else if(type==='uniforme'){
          val = rndUniform(clean.uniA, clean.uniB, rng);
        } else if(type==='exponencial'){
          val = rndExpoShift(clean.expLambda, clean.expShift, rng);
        } else if(type==='tstudent'){
          const raw = rndT(clean.dfT, rng);
          val = clean.tMu + clean.tScale * raw;
        } else if(type==='chisq'){
          const raw = randChiSquare(clean.dfChi, rng);
          val = clean.chiShift + clean.chiScale * raw;
        } else {
          val = rndNormal(50,2, rng);
        }
        data.push(val);
      }
      return data;
    }

    function App() {
      const [type, setType] = useState('normal');
      const [muN, setMuN] = useState(50);
      const [sdN, setSdN] = useState(10);
      const [uniA, setUniA] = useState(30);
      const [uniB, setUniB] = useState(70);
      const [expLambda, setExpLambda] = useState(0.1);
      const [expShift, setExpShift] = useState(40);
      const [dfT, setDfT] = useState(5);
      const [tMu, setTMu] = useState(50);
      const [tScale, setTScale] = useState(10);
      const [dfChi, setDfChi] = useState(5);
      const [chiScale, setChiScale] = useState(2);
      const [chiShift, setChiShift] = useState(40);
      const [seed, setSeed] = useState('');
      const [N, setN] = useState(10000);
      const [n, setn] = useState(30);
      const [B, setB] = useState(500);
      const [withoutReplacement, setWithoutReplacement] = useState(false);
      const [showTheo, setShowTheo] = useState(true);
      const [useSampleParams, setUseSampleParams] = useState(false);
      const [orderByValue, setOrderByValue] = useState(false);
      const [showSamplingProcess, setShowSamplingProcess] = useState(false);
      const [showMeans, setShowMeans] = useState(true);

      const [population, setPopulation] = useState([]);
      const [popStats, setPopStats] = useState(null);
      const [xbar, setXbar] = useState([]);
      const [xbarStats, setXbarStats] = useState(null);
      const [sampleData, setSampleData] = useState([]);
      const [busy, setBusy] = useState(false);
      const [progress, setProgress] = useState(0);

      const popChartRef = useRef(null);
      const smChartRef = useRef(null);
      const samplesChartRef = useRef(null);
      const popChartInstance = useRef(null);
      const smChartInstance = useRef(null);
      const samplesChartInstance = useRef(null);

      // Desmarcar "sin reemplazo" automáticamente si n > N
      useEffect(() => {
        if (withoutReplacement && n > N) {
          setWithoutReplacement(false);
        }
      }, [n, N, withoutReplacement]);

      // Desmarcar "mostrar proceso" automáticamente si B > 100
      useEffect(() => {
        if (showSamplingProcess && B > 100) {
          setShowSamplingProcess(false);
        }
      }, [B, showSamplingProcess]);

      // ---------------------- FUNCIONES DE DESCARGA EXCEL ----------------------
      function downloadPopulationExcel() {
        if (!population || population.length === 0) return;
        
        // Crear datos para la hoja
        const wsData = [
          ['Índice', 'Valor']
        ];
        population.forEach((val, idx) => {
          wsData.push([idx + 1, val]);
        });
        
        // Agregar estadísticas al final
        wsData.push([]);
        wsData.push(['Estadísticas Poblacionales']);
        wsData.push(['Media (μ)', popStats.mean]);
        wsData.push(['Desvío (σ)', popStats.sd]);
        wsData.push(['Tamaño (N)', popStats.N]);
        wsData.push(['Distribución', type]);
        
        // Crear libro y hoja
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        XLSX.utils.book_append_sheet(wb, ws, 'Población');
        
        // Descargar archivo
        XLSX.writeFile(wb, `poblacion_${type}_N${N}.xlsx`);
      }

      function downloadSamplesExcel() {
        if (!sampleData || sampleData.length === 0) return;
        
        // Crear datos para la hoja de muestras
        const maxSampleSize = Math.max(...sampleData.map(s => s.values.length));
        const headers = ['Muestra', 'Promedio', 'Desvío', ...Array.from({length: maxSampleSize}, (_, i) => `Valor ${i+1}`)];
        const wsData = [headers];
        
        sampleData.forEach((sample, idx) => {
          const sampleSd = popSd(sample.values);
          const row = [idx + 1, sample.mean, sampleSd, ...sample.values];
          wsData.push(row);
        });
        
        // Agregar estadísticas al final
        wsData.push([]);
        wsData.push(['Estadísticas de Medias Muestrales']);
        wsData.push(['Media de x̄ (μ_x̄)', xbarStats.mean]);
        wsData.push(['Error estándar empírico (sd[x̄])', xbarStats.sd]);
        if (xbarStats.seTheo != null) {
          wsData.push(['Error estándar teórico', xbarStats.seTheo]);
        }
        wsData.push(['Tamaño muestral (n)', n]);
        wsData.push(['Número de muestras (B)', B]);
        wsData.push(['Muestreo sin reemplazo', withoutReplacement ? 'Sí' : 'No']);
        
        // Crear libro y hoja
        const wb = XLSX.utils.book_new();
        const ws = XLSX.utils.aoa_to_sheet(wsData);
        XLSX.utils.book_append_sheet(wb, ws, 'Muestras');
        
        // Descargar archivo
        XLSX.writeFile(wb, `muestras_n${n}_B${B}.xlsx`);
      }

      // ---------------------- GENERAR POBLACIÓN ----------------------
      function handleGenerate(){
        const params = {muN,sdN,uniA,uniB,expLambda,expShift,dfT,tMu,tScale,dfChi,chiScale,chiShift,seed};
        const pop = generatePop(N, type, params);
        setPopulation(pop);
        const m = mean(pop);
        const s = popSd(pop);
        setPopStats({mean:m, sd:s, N:pop.length});
        setXbar([]);
        setXbarStats(null);
        setSampleData([]);
        setProgress(0);
        console.log("✓ Población generada (N =", N, ", μ =", m.toFixed(2), ", σ =", s.toFixed(2),")");
      }

      // ---------------------- TOMAR MUESTRAS ----------------------
      async function handleSample(){
        if(!popStats || population.length===0) return;
        setBusy(true);
        setProgress(0);
        const allBars = [];
        const allSamples = [];
        const popArr = [...population];
        const cleanN = clampNat(n,1);
        const cleanB = clampNat(B,1);
        const batchSize = 50;
        for(let batch=0; batch<cleanB; batch+=batchSize){
          const todo = Math.min(batchSize, cleanB-batch);
          await new Promise(r=>setTimeout(r,0));
          for(let i=0;i<todo;i++){
            let sample;
            if(withoutReplacement){
              const tempPop = [...popArr];
              sample = [];
              for(let j=0;j<cleanN;j++){
                const idx = Math.floor(Math.random()*tempPop.length);
                sample.push(tempPop[idx]);
                tempPop.splice(idx,1);
              }
            } else {
              sample = [];
              for(let j=0;j<cleanN;j++){
                sample.push(popArr[Math.floor(Math.random()*popArr.length)]);
              }
            }
            const m = mean(sample);
            allBars.push(m);
            allSamples.push({mean:m, values:sample});
          }
          setProgress(batch+todo);
        }
        let seTheo = popStats.sd / Math.sqrt(cleanN);
        if(withoutReplacement && N > 1 && cleanN < N){
          const fpc = Math.sqrt((N-cleanN)/(N-1));
          seTheo *= fpc;
        }
        const xm = mean(allBars);
        const xs = popSd(allBars);
        setXbar(allBars);
        setXbarStats({mean:xm, sd:xs, seTheo});
        setSampleData(allSamples);
        setBusy(false);
        setProgress(cleanB);
        console.log("✓ Muestras tomadas (B =", cleanB, ", n =", cleanN, ", μ_x̄ =", xm.toFixed(2), ", sd[x̄] =", xs.toFixed(2),")");
        console.log("  Teórico SE = σ/√n =", seTheo.toFixed(2));
      }

      function handleClear(){
        setXbar([]);
        setXbarStats(null);
        setSampleData([]);
        setProgress(0);
        console.log("✓ Muestras limpiadas");
      }

      function handleClearPopulation(){
        setPopulation([]);
        setPopStats(null);
        setXbar([]);
        setXbarStats(null);
        setSampleData([]);
        setProgress(0);
        console.log("✓ Población limpiada");
      }

      // ---------------------- CHARTS ----------------------
      useEffect(()=>{
        if(population.length===0) return;
        const {labels,counts} = makeHistogram(population,30);
        const ctx = popChartRef.current?.getContext('2d');
        if(!ctx) return;
        if(popChartInstance.current) popChartInstance.current.destroy();
        popChartInstance.current = new Chart(ctx,{
          type:'bar',
          data:{ 
            labels: labels.map(x=>x.toPrecision(3)), 
            datasets:[{
              label:'Frecuencia', 
              data:counts, 
              backgroundColor:'rgba(37,99,235,0.7)', 
              borderWidth:0,
              barPercentage: 1.0,
              categoryPercentage: 1.0
            }]
          },
          options:{
            responsive:true, 
            maintainAspectRatio:false, 
            plugins:{legend:{display:false}}
          }
        });
      },[population]);

      useEffect(()=>{
        if(xbar.length===0) return;
        const {labels,counts,edges,width} = makeHistogram(xbar,30);
        const ctx = smChartRef.current?.getContext('2d');
        if(!ctx) return;
        if(smChartInstance.current) smChartInstance.current.destroy();
        const datasets = [{
          label:'Frecuencia (x̄)', 
          data:counts, 
          backgroundColor:'rgba(34,197,94,0.7)', 
          borderWidth:0,
          barPercentage: 1.0,
          categoryPercentage: 1.0
        }];
        if(showTheo && xbarStats){
          let muTheo = popStats.mean;
          let seTheo = xbarStats.seTheo;
          if(useSampleParams && xbarStats){
            muTheo = xbarStats.mean;
            seTheo = xbarStats.sd;
          }
          // Solo dibujar si el error estándar es > 0
          if(seTheo > 1e-10 && Number.isFinite(seTheo)){
            const totalCount = counts.reduce((a,b)=>a+b,0);
            const theoFreq = edges.slice(0,-1).map((a,i)=>{
              const b = edges[i+1];
              const p = normalBinMass(a,b,muTheo,seTheo);
              return p * totalCount;
            });
            datasets.push({type:'line', label:'Normal teórica', data:theoFreq, borderColor:'rgba(239,68,68,1)', backgroundColor:'rgba(239,68,68,0.1)', fill:false, pointRadius:0, borderWidth:2});
          }
        }
        smChartInstance.current = new Chart(ctx,{
          type:'bar',
          data:{ labels: labels.map(x=>x.toPrecision(4)), datasets },
          options:{
            responsive:true, 
            maintainAspectRatio:false, 
            plugins:{legend:{display:showTheo}}
          }
        });
      },[xbar, showTheo, useSampleParams, xbarStats]);

      useEffect(()=>{
        if(!showSamplingProcess || sampleData.length===0) return;
        const ctx = samplesChartRef.current?.getContext('2d');
        if(!ctx) return;
        if(samplesChartInstance.current) samplesChartInstance.current.destroy();
        let displayData = [...sampleData];
        if(orderByValue){
          displayData.sort((a,b)=>a.mean-b.mean);
        }
        const datasets = [];
        
        // Dataset para valores individuales
        const individualPoints = [];
        displayData.forEach((s,i)=>{
          const xVal = i+1;
          s.values.forEach(v => {
            individualPoints.push({x:xVal, y:v});
          });
        });
        
        datasets.push({
          label: 'Valores individuales',
          data: individualPoints,
          backgroundColor:'rgba(59,130,246,0.6)',
          pointRadius:3,
          showLine:false,
          order: 2
        });
        
        // Dataset para promedios (solo si showMeans está activado)
        if(showMeans){
          const meanPoints = displayData.map((s,i)=>({
            x: i+1,
            y: s.mean
          }));
          
          datasets.push({
            label: 'Promedio de la muestra',
            data: meanPoints,
            backgroundColor:'rgba(239,68,68,1)',
            pointRadius:5,
            showLine:false,
            order: 1
          });
        }
        
        samplesChartInstance.current = new Chart(ctx,{
          type:'scatter',
          data:{datasets},
          options:{
            responsive:true,
            maintainAspectRatio:false,
            plugins:{legend:{display:true}},
            scales:{
              x:{title:{display:true,text:'Muestra #'}},
              y:{title:{display:true,text:'Valor'}}
            }
          }
        });
      },[sampleData, showSamplingProcess, orderByValue, showMeans]);

      return (
        <div className="container">
          <h1>Simulador de Muestreo — Teorema Central del Límite</h1>
          <p className="sub">Visualizá cómo la distribución de las medias muestrales tiende a una normal</p>
          <div className="grid">
            <div className="card controls">
              <h2>1. Configurar población</h2>
              <div className="row">
                <label>Distribución</label>
                <select value={type} onChange={e=>setType(e.target.value)}>
                  <option value="normal">Normal</option>
                  <option value="uniforme">Uniforme</option>
                  <option value="exponencial">Exponencial</option>
                  <option value="tstudent">t-Student</option>
                  <option value="chisq">Chi-cuadrado</option>
                </select>
              </div>

              {type==='normal' && (
                <div className="two-cols">
                  <div className="row"><label>μ (media)</label><input type="number" value={muN} onChange={e=>setMuN(parseFloat(e.target.value) || 0)} /></div>
                  <div className="row"><label>σ (desvío)</label><input type="number" min="0" step="0.01" value={sdN} onChange={e=>setSdN(parseFloat(e.target.value) || 1)} /></div>
                </div>
              )}

              {type==='uniforme' && (
                <div className="two-cols">
                  <div className="row"><label>a (mínimo)</label><input type="number" value={uniA} onChange={e=>setUniA(parseFloat(e.target.value) || 0)} /></div>
                  <div className="row"><label>b (máximo)</label><input type="number" value={uniB} onChange={e=>setUniB(parseFloat(e.target.value) || 100)} /></div>
                </div>
              )}

              {type==='exponencial' && (
                <div className="two-cols">
                  <div className="row"><label>λ (tasa)</label><input type="number" min="0.0001" step="0.0001" value={expLambda} onChange={e=>setExpLambda(parseFloat(e.target.value) || 0.1)} /></div>
                  <div className="row"><label>Shift</label><input type="number" step="0.01" value={expShift} onChange={e=>setExpShift(parseFloat(e.target.value) || 0)} /></div>
                </div>
              )}

              {type==='tstudent' && (
                <>
                  <div className="row"><label>Grados de libertad (ν)</label><input type="number" min="1" step="1" value={dfT} onChange={e=>setDfT(parseInt(e.target.value)||1)} /></div>
                  <div className="two-cols">
                    <div className="row"><label>μ (centro)</label><input type="number" value={tMu} onChange={e=>setTMu(parseFloat(e.target.value) || 0)} /></div>
                    <div className="row"><label>Escala (s)</label><input type="number" min="0" step="0.01" value={tScale} onChange={e=>setTScale(parseFloat(e.target.value) || 1)} /></div>
                  </div>
                </>
              )}

              {type==='chisq' && (
                <>
                  <div className="row"><label>Grados de libertad (ν)</label><input type="number" min="1" step="1" value={dfChi} onChange={e=>setDfChi(parseInt(e.target.value)||1)} /></div>
                  <div className="two-cols">
                    <div className="row"><label>Escala (a)</label><input type="number" min="0" step="0.0001" value={chiScale} onChange={e=>setChiScale(parseFloat(e.target.value) || 1)} /></div>
                    <div className="row"><label>Shift</label><input type="number" step="0.01" value={chiShift} onChange={e=>setChiShift(parseFloat(e.target.value) || 0)} /></div>
                  </div>
                </>
              )}

              <div className="row">
                <label>Semilla (opcional)</label>
                <input type="text" placeholder="p.ej. 1234, 'clase-tlc', etc." value={seed} onChange={e=>setSeed(e.target.value)} />
              </div>

              <div className="row">
                <label>Tamaño de población (N)</label>
                <input type="number" min="1" step="1" value={N} onChange={e=>setN(clampNat(e.target.value))} />
              </div>
              <button className="btn primary" onClick={handleGenerate}>Generar población</button>
              
              <button className="btn excel" onClick={downloadPopulationExcel} disabled={!popStats}>
                Descargar población (Excel)
              </button>

              <button className="btn danger" onClick={handleClearPopulation} disabled={!popStats}>
                Limpiar población
              </button>

              {popStats && (
                <div className="stats">
                  <h3>Estadísticas poblacionales</h3>
                  <div className="stat"><span>Media (μ):</span><strong>{popStats.mean.toFixed(2)}</strong></div>
                  <div className="stat"><span>Desvío (σ):</span><strong>{popStats.sd.toFixed(2)}</strong></div>
                  <div className="stat"><span>Tamaño (N):</span><strong>{popStats.N.toLocaleString()}</strong></div>
                </div>
              )}

              <h2 style={{marginTop:14}}>2. Configurar muestreo</h2>
              <div className="row">
                <label>Tamaño muestral (n)</label>
                <input type="number" min="1" step="1" value={n} onChange={e=>setn(clampNat(e.target.value))} />
              </div>
              <div className="row">
                <label>Número de muestras (B)</label>
                <input type="number" min="1" step="1" value={B} onChange={e=>setB(clampNat(e.target.value))} />
              </div>
              <div className="row inline">
                <input id="chkWOR" type="checkbox" checked={withoutReplacement} onChange={e=>setWithoutReplacement(e.target.checked)} disabled={!popStats || n > N} />
                <label htmlFor="chkWOR" style={{margin:0}}>Muestrear <strong>sin</strong> reemplazo (aplica FPC) {n > N ? '(n debe ser ≤ N)' : ''}</label>
              </div>
              <div className="row inline">
                <input id="chkTheo" type="checkbox" checked={showTheo} onChange={e=>setShowTheo(e.target.checked)} />
                <label htmlFor="chkTheo" style={{margin:0}}>Mostrar normal teórica</label>
              </div>
              <div className="row inline indent">
                <input id="chkSampleParams" type="checkbox" disabled={!xbarStats} checked={useSampleParams} onChange={e=>setUseSampleParams(e.target.checked)} />
                <label htmlFor="chkSampleParams" style={{margin:0}}>Usar estimación muestral (x̄, sd[x̄])</label>
              </div>
              <div className="row inline">
                <input id="chkOrder" type="checkbox" disabled={!sampleData || sampleData.length === 0} checked={orderByValue} onChange={e=>setOrderByValue(e.target.checked)} />
                <label htmlFor="chkOrder" style={{margin:0}}>Ordenar muestras por valor del promedio</label>
              </div>
              <div className="row inline">
                <input id="chkProcess" type="checkbox" disabled={!sampleData || sampleData.length === 0 || B > 100} checked={showSamplingProcess} onChange={e=>setShowSamplingProcess(e.target.checked)} />
                <label htmlFor="chkProcess" style={{margin:0}}>Mostrar proceso de muestreo {B > 100 ? '(deshabilitado para B > 100)' : ''}</label>
              </div>
              <div className="row inline indent">
                <input id="chkMeans" type="checkbox" disabled={!showSamplingProcess || !sampleData || sampleData.length === 0} checked={showMeans} onChange={e=>setShowMeans(e.target.checked)} />
                <label htmlFor="chkMeans" style={{margin:0}}>Mostrar promedios (puntos rojos)</label>
              </div>

              <button className="btn success" onClick={handleSample} disabled={!popStats || busy}>Tomar muestras</button>
              
              <button className="btn excel" onClick={downloadSamplesExcel} disabled={!xbarStats}>
                Descargar muestras (Excel)
              </button>
              
              <button className="btn danger" onClick={handleClear} disabled={xbar.length===0 || busy}>Limpiar muestras</button>

              <div className="progress" style={{display: busy || (progress>0 && progress<B) ? 'block' : 'none'}}>
                {busy ? `Tomando muestras… ${progress}/${B}` : null}
              </div>

              {xbarStats && (
                <div className="stats">
                  <h3>Estadísticas de medias muestrales</h3>
                  <div className="stat"><span>Media de x̄ (μ_x̄):</span><strong>{xbarStats.mean.toFixed(2)}</strong></div>
                  <div className="stat"><span>Error estándar empírico (sd[x̄]):</span><strong>{xbarStats.sd.toFixed(2)}</strong></div>
                  {xbarStats.seTheo!=null && (
                    <div className="stat"><span>Error estándar teórico:</span><strong>{xbarStats.seTheo.toFixed(2)}</strong></div>
                  )}
                </div>
              )}

              <div className="info"><strong>TLC:</strong> A medida que n crece, la distribución de <em>x̄</em> se aproxima a una normal con media μ y desvío σ/√n; si muestreamos <em>sin</em> reemplazo, se multiplica además por la FPC √((N−n)/(N−1)).</div>

              <div className="tests">
                <strong>Self-tests:</strong> abrí la consola para ver <code>✓</code>/<code>✗</code>.
              </div>
            </div>
            <div className={`charts ${showSamplingProcess ? 'three-charts' : 'two-charts'}`}>
              <div className="chart-card">
                <h3>Histograma de la población</h3>
                <div className="chart-wrap"><canvas ref={popChartRef}></canvas></div>
              </div>
              {showSamplingProcess && (
                <div className="chart-card">
                  <h3>Proceso de muestreo</h3>
                  <div className="chart-wrap"><canvas ref={samplesChartRef}></canvas></div>
                </div>
              )}
              <div className="chart-card">
                <h3>Histograma de medias muestrales</h3>
                <div className="chart-wrap"><canvas ref={smChartRef}></canvas></div>
              </div>
            </div>
            <div style={{gridColumn:'1 / -1', marginTop: 16, textAlign:'center', color:'#6b7280', fontSize:12}}>
              <strong>Sergio Ruminot - 2025</strong><br/>
              Departamento de Estadística - FAEA<br/>
              Universidad Nacional del Comahue
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>