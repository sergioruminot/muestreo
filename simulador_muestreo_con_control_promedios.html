<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simulador de Muestreo ‚Äî Teorema Central del L√≠mite</title>
  <!-- React 18 + Babel (para JSX en un solo archivo HTML) -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, 'Helvetica Neue', Arial, 'Noto Sans', 'Apple Color Emoji', 'Segoe UI Emoji'; background:#f5f5f5; padding: 20px; }
    .container { max-width: 1400px; margin: 0 auto; background: #fff; padding: 28px; border-radius: 14px; box-shadow: 0 8px 28px rgba(0,0,0,.08); }
    h1 { text-align:center; font-weight:800; letter-spacing:.2px; color:#111827; margin-bottom: 8px; }
    .sub { text-align:center; color:#6b7280; margin-bottom: 14px; font-size: 14px; }
    .grid { display:grid; grid-template-columns: 360px 1fr; gap: 26px; min-height: 720px; }
    .card { background:#fff; border:1px solid #e5e7eb; border-radius: 12px; padding: 18px; box-shadow: 0 2px 10px rgba(0,0,0,.04); }
    .controls { background:#fafafa; }
    .card h2 { font-size: 16px; color:#111827; margin-bottom: 12px; }
    .row { margin-bottom: 14px; }
    label { display:block; font-weight:700; font-size: 12px; color:#374151; margin-bottom: 6px; }
    .inline { display:flex; align-items:center; gap:8px; }
    .indent { margin-left: 28px; }
    select, input[type="number"], input[type="text"] { width: 100%; padding: 10px 12px; border-radius: 10px; border:2px solid #e5e7eb; background:#fff; font-size: 14px; }
    select:focus, input:focus { outline:none; border-color:#2563eb; }
    input[type="checkbox"]{ transform: translateY(1px); }
    .two-cols { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .btn { width:100%; padding: 12px; border:none; border-radius: 12px; font-weight: 800; cursor:pointer; transition: .2s; margin-bottom: 10px; letter-spacing:.2px; }
    .btn.primary { background:#2563eb; color:#fff; }
    .btn.primary:hover { background:#1d4ed8; }
    .btn.success { background:#16a34a; color:#fff; }
    .btn.success:hover { background:#15803d; }
    .btn.danger { background:#dc2626; color:#fff; }
    .btn.danger:hover { background:#b91c1c; }
    .stats { background:#eef2ff; border-left:4px solid #4f46e5; padding: 12px; border-radius: 10px; margin: 10px 0 14px; }
    .stats h3 { font-size: 12px; color:#4338ca; margin-bottom: 6px; }
    .stat { display:flex; justify-content:space-between; font-size: 13px; margin: 2px 0; color:#1f2937; }
    .charts { display:grid; gap:18px; }
    .charts.three-charts { grid-template-rows: 1fr 1fr 1fr; }
    .charts.two-charts { grid-template-rows: 1fr 1fr; }
    .chart-card { border:1px solid #e5e7eb; border-radius: 12px; padding: 12px; background:#fff; }
    .chart-card h3 { text-align:center; font-size: 14px; color:#374151; margin-bottom: 8px; }
    .chart-wrap { position:relative; height: 280px; }
    .info { background:#fef3c7; color:#92400e; border:1px solid #f59e0b; padding:10px; border-radius:10px; font-size: 12px; text-align:center; }
    .progress { background:#dcfce7; color:#166534; border:1px solid #16a34a; border-radius:10px; padding:8px; font-size: 12px; text-align:center; margin: 8px 0; display:none; }
    .tests { margin-top: 10px; font-size: 12px; color:#374151; }
    .tests code { background:#f3f4f6; padding: 2px 6px; border-radius:6px; }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // ---------------- PRNG con semilla -----------------
    function strToSeed(str){
      if(!str || str.length===0) return 0x9E3779B9; // constante por defecto
      let h = 1779033703 ^ str.length;
      for(let i=0;i<str.length;i++){
        h = Math.imul(h ^ str.charCodeAt(i), 3432918353);
        h = (h << 13) | (h >>> 19);
      }
      return h >>> 0;
    }
    function mulberry32(a){
      let t = a >>> 0;
      return function(){
        t += 0x6D2B79F5; t = Math.imul(t ^ (t >>> 15), t | 1);
        t ^= t + Math.imul(t ^ (t >>> 7), t | 61);
        return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
      };
    }

    // Utilidades ---------------------------------------------------------------
    const mean = arr => arr.reduce((a,b)=>a+b,0)/arr.length;
    const popVar = (arr, m) => arr.reduce((s,x)=>s+(x-m)**2,0)/arr.length; // var poblacional
    const popSd = (arr) => Math.sqrt(popVar(arr, mean(arr)));

    const clampNat = (x, min=1) => {
      const v = Math.floor(Number(x));
      return (Number.isFinite(v) && v >= min) ? v : min;
    };
    const safeNum = (x, fallback) => {
      const v = Number(x);
      return Number.isFinite(v) ? v : fallback;
    };

    function makeHistogram(data, bins=30){
      const min = Math.min(...data), max = Math.max(...data);
      const width = (max-min)/bins || 1;
      const edges = Array.from({length: bins+1}, (_,i)=>min+i*width);
      const counts = new Array(bins).fill(0);
      for(const v of data){
        let k = Math.floor((v-min)/width);
        if(k>=bins) k=bins-1;
        if(k<0 || !Number.isFinite(k)) k=0;
        counts[k]++;
      }
      const labels = edges.slice(0,-1).map((e)=> (e+width/2));
      return {labels, counts, edges, width};
    }

    // Normal CDF ---------------------------------------------------------------
    function erf(x){
      const sign = x < 0 ? -1 : 1;
      x = Math.abs(x);
      const a1=0.254829592, a2=-0.284496736, a3=1.421413741, a4=-1.453152027, a5=1.061405429, p=0.3275911;
      const t = 1/(1+p*x);
      const y = 1 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*Math.exp(-x*x);
      return sign*y;
    }
    const Phi = z => 0.5*(1+erf(z/Math.SQRT2));
    const normalBinMass = (a,b,mu,sd) => Phi((b-mu)/sd) - Phi((a-mu)/sd);

    // Generadores (seed-aware) -------------------------------------------------
    function rndNormal(mean=50, sd=2, rng=Math.random){
      const u1 = Math.max(rng(), 1e-16);
      const u2 = Math.max(rng(), 1e-16);
      const z = Math.sqrt(-2*Math.log(u1))*Math.cos(2*Math.PI*u2);
      return mean + sd*z;
    }
    function rndUniform(a=30,b=70, rng=Math.random){ return a + rng()*(b-a); }
    function rndExpoShift(lambda=0.1, shift=40, rng=Math.random){ return -Math.log(1 - Math.min(rng(), 1-1e-16))/lambda + shift; }
    function randChiSquare(df, rng=Math.random){
      df = Math.max(1, Math.floor(df));
      let s = 0;
      for(let i=0;i<df;i++){ const z = rndNormal(0,1, rng); s += z*z; }
      return s;
    }
    function rndT(df, rng=Math.random){
      const z = rndNormal(0,1, rng);
      const chi = randChiSquare(df, rng);
      return z / Math.sqrt(chi/df);
    }

    function sanitizeParams(type, params){
      // Asegurar n√∫meros finitos y dominios v√°lidos
      const out = {...params};
      if(type==='normal'){
        out.muN = safeNum(params.muN, 0);
        out.sdN = Math.abs(safeNum(params.sdN, 1));
      }
      if(type==='uniforme'){
        let a = safeNum(params.uniA, 0), b = safeNum(params.uniB, 1);
        if(!Number.isFinite(a)) a = 0; if(!Number.isFinite(b)) b = 1;
        if(b < a){ const t=a; a=b; b=t; }
        out.uniA = a; out.uniB = b;
      }
      if(type==='exponencial'){
        out.expLambda = Math.max(1e-8, safeNum(params.expLambda, 1));
        out.expShift  = safeNum(params.expShift, 0);
      }
      if(type==='tstudent'){
        out.dfT    = clampNat(params.dfT, 1);
        out.tMu    = safeNum(params.tMu, 0);
        out.tScale = Math.abs(safeNum(params.tScale, 1));
      }
      if(type==='chisq'){
        out.dfChi    = clampNat(params.dfChi, 1);
        out.chiScale = Math.max(0, safeNum(params.chiScale, 1));
        out.chiShift = safeNum(params.chiShift, 0);
      }
      return out;
    }

    function generatePopulation(type, N, params, rng=Math.random){
      const NN = clampNat(N, 1);
      const p = sanitizeParams(type, params);
      const arr = new Array(NN);
      for(let i=0;i<NN;i++){
        if(type==='normal') arr[i]=rndNormal(p.muN, p.sdN, rng);
        else if(type==='uniforme') arr[i]=rndUniform(p.uniA, p.uniB, rng);
        else if(type==='exponencial') arr[i]=rndExpoShift(p.expLambda, p.expShift, rng);
        else if(type==='tstudent') arr[i] = p.tMu + p.tScale * rndT(p.dfT, rng);
        else if(type==='chisq') arr[i] = p.chiShift + p.chiScale * randChiSquare(p.dfChi, rng);
        else arr[i]=rndNormal(50,2, rng);
        if(!Number.isFinite(arr[i])) arr[i] = 0; // fallback duro ante NaNs
      }
      return arr;
    }

    function sampleMeans(pop, n, B, rng=Math.random, withoutReplacement=false){
      const n0 = clampNat(n, 1);
      const B0 = clampNat(B, 1);
      const N = pop.length;
      const out = new Array(B0);
      for(let b=0;b<B0;b++){
        let s = 0;
        if (withoutReplacement) {
          if(n0 >= N){ out[b] = mean(pop); continue; }
          const used = new Set();
          while(used.size < n0){
            const j = Math.floor(rng()*N);
            if(!used.has(j)) { used.add(j); s += pop[j]; }
          }
          out[b] = s / n0;
        } else {
          for(let i=0;i<n0;i++){
            const j = Math.floor(rng()*N);
            s += pop[j];
          }
          out[b] = s / n0;
        }
      }
      return out;
    }

    function sampleWithDetails(pop, n, B, rng=Math.random, withoutReplacement=false){
      const n0 = clampNat(n, 1);
      const B0 = clampNat(B, 1);
      const N = pop.length;
      const means = new Array(B0);
      const individualSamples = new Array(B0);
      
      for(let b=0;b<B0;b++){
        const sample = [];
        let s = 0;
        
        if (withoutReplacement) {
          if(n0 >= N){ 
            means[b] = mean(pop);
            individualSamples[b] = [...pop].slice(0, n0);
            continue; 
          }
          const used = new Set();
          while(used.size < n0){
            const j = Math.floor(rng()*N);
            if(!used.has(j)) { 
              used.add(j); 
              const val = pop[j];
              sample.push(val);
              s += val; 
            }
          }
        } else {
          for(let i=0;i<n0;i++){
            const j = Math.floor(rng()*N);
            const val = pop[j];
            sample.push(val);
            s += val;
          }
        }
        
        means[b] = s / n0;
        individualSamples[b] = sample;
      }
      
      return { means, individualSamples };
    }

    // Componente principal -----------------------------------------------------
    function App(){
      const [type, setType] = useState('normal'); const [N, setN] = useState(30);
      // Par√°metros por distribuci√≥n
      const [muN, setMuN] = useState(0);     // normal Œº
      const [sdN, setSdN] = useState(1);      // normal œÉ

      const [uniA, setUniA] = useState(30);   // uniforme a
      const [uniB, setUniB] = useState(70);   // uniforme b

      const [expLambda, setExpLambda] = useState(0.1); // exponencial Œª
      const [expShift, setExpShift] = useState(40);    // exponencial shift

      const [dfT, setDfT] = useState(5);      // t df
      const [tMu, setTMu] = useState(50);     // t centro
      const [tScale, setTScale] = useState(2);// t escala (SD aprox si ŒΩ grande)

      const [dfChi, setDfChi] = useState(10); // œá¬≤ df
      const [chiScale, setChiScale] = useState(50/10); // œá¬≤ escala (por defecto media‚âà50)
      const [chiShift, setChiShift] = useState(0);     // œá¬≤ shift

      // Semilla
      const [seed, setSeed] = useState("");  // semilla opcional

      const [pop, setPop] = useState([]);
      const [popStats, setPopStats] = useState(null);

      const [n, setn] = useState(10);
      const [B, setB] = useState(10);
      const [xbar, setXbar] = useState([]);
      const [xbarStats, setXbarStats] = useState(null);
      const [sampleData, setSampleData] = useState([]); // Para almacenar datos individuales de cada muestra
      const [showTheo, setShowTheo] = useState(false);
      const [useSampleParams, setUseSampleParams] = useState(false);
      const [orderByValue, setOrderByValue] = useState(false); // Para ordenar muestras por valor del promedio
      const [showSamplingProcess, setShowSamplingProcess] = useState(true); // Para mostrar/ocultar gr√°fico de proceso
      const [showMeans, setShowMeans] = useState(true); // Para mostrar/ocultar puntos rojos (promedios)
      const [busy, setBusy] = useState(false);
      const [progress, setProgress] = useState(0);
      const [withoutReplacement, setWithoutReplacement] = useState(false);

      const popChartRef = useRef(null); const popChart = useRef(null);
      const smChartRef = useRef(null);  const smChart  = useRef(null);
      const samplesChartRef = useRef(null); const samplesChart = useRef(null); // Gr√°fico de muestras individuales

      const currentParams = () => ({
        muN, sdN, uniA, uniB, expLambda, expShift,
        dfT, tMu, tScale, dfChi, chiScale, chiShift
      });

      const makeRng = (channel) => {
        if(!seed) return Math.random; // sin semilla: aleatorio normal del navegador
        const s = strToSeed(`${seed}:${channel}`);
        return mulberry32(s);
      };

      const handleGenerate = () => {
        const safeN = clampNat(N, 1);
        if(N !== safeN) setN(safeN);
        if (safeN > 100000 && !confirm(`Vas a generar una poblaci√≥n de N=${safeN.toLocaleString()}. Esto puede ser pesado para el navegador. ¬øContinuar?`)) return;
        const rng = makeRng('pop');
        const p = generatePopulation(type, safeN, currentParams(), rng);
        const m = mean(p); const sd = popSd(p);
        setPop(p); setPopStats({mean:m, sd, N:safeN});
        setXbar([]); setXbarStats(null);
      };

      const handleSample = async () => {
        const safen = clampNat(n, 1);
        const safeB = clampNat(B, 1);
        if(n !== safen) setn(safen);
        if(B !== safeB) setB(safeB);
        const ops = safen * safeB;
        if (ops > 5e7 && !confirm(`Vas a simular B=${safeB.toLocaleString()} medias con n=${safen.toLocaleString()} (‚âà ${ops.toLocaleString()} operaciones). Esto puede colgar el navegador. ¬øContinuar?`)) return;
        if(!pop || pop.length===0) return;
        setBusy(true); setProgress(0); setXbar([]); setXbarStats(null); setSampleData([]);
        const rng = makeRng('samp');
        // animar progreso con batches
        const batches = Math.min(safeB, 50);
        const perBatch = Math.ceil(safeB/batches);
        let acc = [];
        let allSampleData = [];
        for(let b=0;b<batches;b++){
          const todo = (b===batches-1) ? (safeB - perBatch*(batches-1)) : perBatch;
          const result = sampleWithDetails(pop, safen, todo, rng, withoutReplacement);
          acc = acc.concat(result.means);
          allSampleData = allSampleData.concat(result.individualSamples);
          setXbar([...acc]);
          setSampleData([...allSampleData]);
          setProgress(Math.min(safeB, perBatch*(b+1)));
          await new Promise(r=>setTimeout(r, 10));
        }
        const m = mean(acc), sd = popSd(acc);
        let seTheo = null;
        if (popStats) {
          if (withoutReplacement) {
            const fpc = (popStats.N>1) ? Math.sqrt((popStats.N - safen)/(popStats.N - 1)) : 1;
            seTheo = (popStats.sd/Math.sqrt(safen)) * fpc;
          } else {
            seTheo = popStats.sd/Math.sqrt(safen);
          }
        }
        setXbarStats({mean:m, sd, seTheo});
        setBusy(false);
      };

      const handleClear = () => { setXbar([]); setXbarStats(null); setProgress(0); setSampleData([]); };

      // Dibujar/actualizar histograma de poblaci√≥n
      useEffect(()=>{
        if(!pop || pop.length===0) { if(popChart.current){popChart.current.destroy(); popChart.current=null;} return; }
        const {labels, counts} = makeHistogram(pop, 30);
        const ctx = popChartRef.current.getContext('2d');
        if(popChart.current) popChart.current.destroy();
        popChart.current = new Chart(ctx, {
          type: 'bar',
          data: { labels: labels.map(v=>v.toFixed(1)), datasets: [{ label:'Frecuencia', data: counts, backgroundColor: 'rgba(37,99,235,0.65)', borderColor:'#2563eb' }] },
          options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:false} }, scales:{ x:{ ticks:{ maxTicksLimit:10 }, title:{display:true, text:'Valor'}}, y:{ title:{display:true, text:'Frecuencia'} } } }
        });
      }, [pop]);

      // Dibujar/actualizar histograma de medias muestrales + normal te√≥rica opcional
      useEffect(()=>{
        if(!xbar || xbar.length===0) { if(smChart.current){smChart.current.destroy(); smChart.current=null;} return; }
        const {labels, counts, edges} = makeHistogram(xbar, 20);
        const ctx = smChartRef.current.getContext('2d');
        if(smChart.current) smChart.current.destroy();

        const datasets = [{
          type: 'bar',
          label: 'Frecuencia',
          data: counts,
          backgroundColor: 'rgba(22,163,74,0.6)',
          borderColor: '#16a34a'
        }];

        if(showTheo && popStats && n>0){
          let mu, sd, lbl;
          if(useSampleParams && xbarStats){
            mu = xbarStats.mean;            // usar estimaci√≥n muestral
            sd = xbarStats.sd;              // sd de XÃÑ (emp√≠rica)
            lbl = 'Normal estimada (xÃÑ, sd[xÃÑ])';
          } else {
            mu = popStats.mean;             // usar par√°metros poblacionales
            if (withoutReplacement) {
              const fpc = (popStats.N>1) ? Math.sqrt((popStats.N - n)/(popStats.N - 1)) : 1;
              sd = (popStats.sd / Math.sqrt(n)) * fpc;
              lbl = 'Normal te√≥rica (Œº pobl., œÉ/‚àön¬∑FPC)';
            } else {
              sd = (popStats.sd / Math.sqrt(n));
              lbl = 'Normal te√≥rica (Œº pobl., œÉ/‚àön)';
            }
          }
          const total = xbar.length;
          const theoCounts = [];
          if(sd > 0 && Number.isFinite(sd)){
            for(let i=0;i<edges.length-1;i++){
              const mass = normalBinMass(edges[i], edges[i+1], mu, sd);
              theoCounts.push(mass * total);
            }
            datasets.push({
              type: 'line',
              label: lbl,
              data: theoCounts,
              borderColor: useSampleParams ? '#a855f7' : '#0ea5e9',
              borderWidth: 2,
              pointRadius: 0,
              tension: 0.25
            });
          } else {
            console.warn('No se dibuja la normal te√≥rica: œÉ ‚â§ 0 o no finita.');
          }
        }

        smChart.current = new Chart(ctx, {
          type: 'bar',
          data: { labels: labels.map(v=>v.toFixed(2)), datasets },
          options: { responsive:true, maintainAspectRatio:false, plugins:{ legend:{display:true} }, scales:{ x:{ ticks:{ maxTicksLimit:10 }, title:{display:true, text:'Media de la muestra (xÃÑ)'}}, y:{ title:{display:true, text:'Frecuencia'} } } }
        });
      }, [xbar, showTheo, useSampleParams, popStats, n, xbarStats, withoutReplacement]);

      // Dibujar/actualizar gr√°fico de muestras individuales
      useEffect(() => {
        if (!showSamplingProcess || !sampleData || sampleData.length === 0 || !xbar || xbar.length === 0) {
          if (samplesChart.current) {
            samplesChart.current.destroy();
            samplesChart.current = null;
          }
          return;
        }

        const ctx = samplesChartRef.current.getContext('2d');
        if (samplesChart.current) samplesChart.current.destroy();

        // Preparar datos para el gr√°fico de scatter
        const datasets = [];
        
        // Crear array de √≠ndices para ordenamiento
        let sampleOrder;
        if (orderByValue) {
          // Crear pares de (promedio, √≠ndice) y ordenar por promedio
          const indexedMeans = xbar.map((mean, index) => ({ mean, index }));
          indexedMeans.sort((a, b) => a.mean - b.mean);
          sampleOrder = indexedMeans.map(item => item.index);
        } else {
          // Orden cronol√≥gico original
          sampleOrder = Array.from({ length: xbar.length }, (_, i) => i);
        }
        
        // Dataset para valores individuales (c√≠rculos azules) - PRIMERO para que est√©n atr√°s
        const individualPoints = [];
        sampleOrder.forEach((originalIndex, displayIndex) => {
          const sample = sampleData[originalIndex];
          sample.forEach((value, valueIndex) => {
            individualPoints.push({
              x: displayIndex + 1, // Posici√≥n en el display (1, 2, 3, ...)
              y: value,
              originalSampleIndex: originalIndex,
              displaySampleIndex: displayIndex,
              valueIndex: valueIndex
            });
          });
        });

        datasets.push({
          label: 'Valores individuales',
          data: individualPoints,
          backgroundColor: 'rgba(59, 130, 246, 0.6)', // Azul m√°s transparente
          borderColor: 'rgba(59, 130, 246, 0.8)',
          borderWidth: 1,
          pointRadius: 5,
          pointHoverRadius: 7,
          showLine: false,
          order: 2 // Mayor n√∫mero = atr√°s
        });

        // Dataset para promedios (c√≠rculos rojos) - solo si showMeans est√° activado
        if (showMeans) {
          const meanPoints = sampleOrder.map((originalIndex, displayIndex) => ({
            x: displayIndex + 1,
            y: xbar[originalIndex],
            originalSampleIndex: originalIndex
          }));

          datasets.push({
            label: 'Promedio de la muestra',
            data: meanPoints,
            backgroundColor: 'rgba(220, 38, 38, 0.9)', // Rojo m√°s opaco
            borderColor: 'rgba(220, 38, 38, 1)',
            borderWidth: 2,
            pointRadius: 7,
            pointHoverRadius: 9,
            showLine: false,
            order: 1 // Menor n√∫mero = adelante
          });
        }

        samplesChart.current = new Chart(ctx, {
          type: 'scatter',
          data: { datasets },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: { display: true },
              tooltip: {
                callbacks: {
                  title: function(context) {
                    const point = context[0];
                    const displayPos = point.parsed.x;
                    if (orderByValue) {
                      const originalIndex = sampleOrder[displayPos - 1];
                      return `Muestra original ${originalIndex + 1} (posici√≥n ${displayPos})`;
                    } else {
                      return `Muestra ${displayPos}`;
                    }
                  },
                  label: function(context) {
                    const dataset = context.dataset;
                    if (dataset.label === 'Valores individuales') {
                      return `Valor: ${context.parsed.y.toFixed(2)}`;
                    } else {
                      return `Promedio: ${context.parsed.y.toFixed(2)}`;
                    }
                  }
                }
              }
            },
            scales: {
              x: {
                title: { 
                  display: true, 
                  text: orderByValue ? 'Posici√≥n (ordenado por promedio)' : 'N√∫mero de muestra (orden cronol√≥gico)'
                },
                type: 'linear',
                min: 0.5,
                max: Math.max(10, sampleData.length + 0.5),
                ticks: {
                  stepSize: 1,
                  callback: function(value) {
                    return Number.isInteger(value) ? value : '';
                  }
                }
              },
              y: {
                title: { display: true, text: 'Valor' }
              }
            },
            interaction: {
              intersect: false
            }
          }
        });
      }, [sampleData, xbar, orderByValue, showSamplingProcess, showMeans]);

      // Autogenerar poblaci√≥n al montar
      useEffect(()=>{ handleGenerate(); }, []);

      // Auto-desactivar proceso de muestreo si B > 100
      useEffect(() => {
        if (B > 100) {
          setShowSamplingProcess(false);
          setShowMeans(false); // Tambi√©n desactivar promedios
        } else if (B <= 100 && sampleData.length > 0) {
          setShowSamplingProcess(true);
          setShowMeans(true); // Activar promedios por defecto
        }
      }, [B, sampleData.length]);

      // Auto-desactivar promedios cuando se desactiva el proceso de muestreo
      useEffect(() => {
        if (!showSamplingProcess) {
          setShowMeans(false);
        }
      }, [showSamplingProcess]);

      // -----------------------------
      // Self-tests (se muestran por consola)
      // -----------------------------
      useEffect(()=>{
        try{
          console.group("Self-tests");
          // 1) Histograma: sum(counts) = length
          const data = [1,2,3,4,5,6,7,8,9,10];
          const h = makeHistogram(data, 5);
          const sumCounts = h.counts.reduce((a,b)=>a+b,0);
          console.log(sumCounts === data.length ? '‚úì Histograma: OK' : '‚úó Histograma');

          // 2) Generadores: tama√±os correctos
          const pN = generatePopulation('normal', 123, {muN:0, sdN:1, uniA:0, uniB:1, expLambda:1, expShift:0, dfT:5, tMu:0, tScale:1, dfChi:3, chiScale:1, chiShift:0}, mulberry32(1));
          console.log(pN.length === 123 ? '‚úì Poblaci√≥n normal tama√±o: OK' : '‚úó Poblaci√≥n normal tama√±o');

          // 3) sampleMeans: B
          const sm = sampleMeans([0,1,2,3,4], 2, 50, mulberry32(2));
          console.log(sm.length === 50 ? '‚úì sampleMeans tama√±o: OK' : '‚úó sampleMeans tama√±o');

          // 4) Overlay normal: masa total ‚âà B
          const rng = mulberry32(3);
          const xs = Array.from({length:200}, ()=>rndNormal(0,1, rng));
          const hb = makeHistogram(xs, 20);
          const tot = xs.length;
          const mu0 = mean(xs), sd0 = popSd(xs);
          let theoTot = 0; for(let i=0;i<hb.edges.length-1;i++){ theoTot += normalBinMass(hb.edges[i], hb.edges[i+1], mu0, sd0)*tot; }
          console.log(Math.abs(theoTot - tot) < tot*0.05 ? '‚úì Overlay normal suma ‚âà total' : '‚úó Overlay normal suma');

          // 5) Sanitizaci√≥n: N=0 y B=0/n=0 no revientan
          const p0 = generatePopulation('normal', 0, {muN:0, sdN:1, uniA:0, uniB:1, expLambda:1, expShift:0, dfT:5, tMu:0, tScale:1, dfChi:3, chiScale:1, chiShift:0}, mulberry32(4));
          console.log(p0.length >= 1 ? '‚úì generatePopulation clamp N>=1' : '‚úó generatePopulation clamp');
          const sm0 = sampleMeans([10,20], 0, 0, mulberry32(5));
          console.log(sm0.length >= 1 ? '‚úì sampleMeans clamp B>=1,n>=1' : '‚úó sampleMeans clamp');
          console.log(clampNat(-5)===1 && clampNat('abc')===1 && clampNat('10.7')===10 ? '‚úì clampNat' : '‚úó clampNat');

          // 6) Extra: reemplazo: poblaci√≥n constante ‚áí medias iguales
          const popConst = [7,7,7];
          const smConst = sampleMeans(popConst, 3, 10, mulberry32(6), false);
          const okConst = smConst.every(v => v === 7);
          console.log(okConst ? '‚úì reemplazo: poblaci√≥n constante' : '‚úó reemplazo: poblaci√≥n constante');

          // 7) Extra: sin reemplazo n=N ‚áí media poblacional
          const popSmall = [1,2,3];
          const smAll = sampleMeans(popSmall, 3, 5, mulberry32(7), true);
          const okAll = smAll.every(v => v === mean(popSmall));
          console.log(okAll ? '‚úì sin reemplazo n=N' : '‚úó sin reemplazo n=N');

          console.groupEnd();
        }catch(e){ console.warn('Self-tests error', e); }
      },[]);

      return (
        <div className="container">
          <h1>Simulador de Muestreo</h1>
          <p className="sub">Teorema Central del L√≠mite</p>
          <p className="sub">Gener√° una poblaci√≥n, tom√° muchas muestras y mir√° c√≥mo se comportan las medias muestrales.</p>
          <div className="grid">
            <div className="card controls">
              <h2>1Ô∏è‚É£ Configurar poblaci√≥n</h2>
              <div className="row">
                <label>Tipo de distribuci√≥n</label>
                <select value={type} onChange={e=>setType(e.target.value)}>
                  <option value="normal">Normal</option>
                  <option value="uniforme">Uniforme</option>
                  <option value="exponencial">Exponencial (sesgada)</option>
                  <option value="tstudent">t-Student</option>
                  <option value="chisq">Chi-cuadrado</option>
                </select>
              </div>

              {type==='normal' && (
                <div className="two-cols">
                  <div className="row"><label>Œº (media)</label><input type="number" value={muN} onChange={e=>setMuN(parseFloat(e.target.value))} /></div>
                  <div className="row"><label>œÉ (desv√≠o)</label><input type="number" min="0" step="0.01" value={sdN} onChange={e=>setSdN(parseFloat(e.target.value))} /></div>
                </div>
              )}

              {type==='uniforme' && (
                <div className="two-cols">
                  <div className="row"><label>a (m√≠nimo)</label><input type="number" value={uniA} onChange={e=>setUniA(parseFloat(e.target.value))} /></div>
                  <div className="row"><label>b (m√°ximo)</label><input type="number" value={uniB} onChange={e=>setUniB(parseFloat(e.target.value))} /></div>
                </div>
              )}

              {type==='exponencial' && (
                <div className="two-cols">
                  <div className="row"><label>Œª (tasa)</label><input type="number" min="0.0001" step="0.0001" value={expLambda} onChange={e=>setExpLambda(parseFloat(e.target.value))} /></div>
                  <div className="row"><label>Shift</label><input type="number" step="0.01" value={expShift} onChange={e=>setExpShift(parseFloat(e.target.value))} /></div>
                </div>
              )}

              {type==='tstudent' && (
                <>
                  <div className="row"><label>Grados de libertad (ŒΩ)</label><input type="number" min="1" step="1" value={dfT} onChange={e=>setDfT(parseInt(e.target.value)||1)} /></div>
                  <div className="two-cols">
                    <div className="row"><label>Œº (centro)</label><input type="number" value={tMu} onChange={e=>setTMu(parseFloat(e.target.value))} /></div>
                    <div className="row"><label>Escala (s)</label><input type="number" min="0" step="0.01" value={tScale} onChange={e=>setTScale(parseFloat(e.target.value))} /></div>
                  </div>
                </>
              )}

              {type==='chisq' && (
                <>
                  <div className="row"><label>Grados de libertad (ŒΩ)</label><input type="number" min="1" step="1" value={dfChi} onChange={e=>setDfChi(parseInt(e.target.value)||1)} /></div>
                  <div className="two-cols">
                    <div className="row"><label>Escala (a)</label><input type="number" min="0" step="0.0001" value={chiScale} onChange={e=>setChiScale(parseFloat(e.target.value))} /></div>
                    <div className="row"><label>Shift</label><input type="number" step="0.01" value={chiShift} onChange={e=>setChiShift(parseFloat(e.target.value))} /></div>
                  </div>
                </>
              )}

              <div className="row">
                <label>Semilla (opcional)</label>
                <input type="text" placeholder="p.ej. 1234, 'clase-tlc', etc." value={seed} onChange={e=>setSeed(e.target.value)} />
              </div>

              <div className="row">
                <label>Tama√±o de poblaci√≥n (N)</label>
                <input type="number" min="1" step="1" value={N} onChange={e=>setN(clampNat(e.target.value))} />
                
              </div>
              <button className="btn primary" onClick={handleGenerate}>Generar poblaci√≥n</button>

              {popStats && (
                <div className="stats">
                  <h3>üìä Estad√≠sticas poblacionales</h3>
                  <div className="stat"><span>Media (Œº):</span><strong>{popStats.mean.toFixed(2)}</strong></div>
                  <div className="stat"><span>Desv√≠o (œÉ):</span><strong>{popStats.sd.toFixed(2)}</strong></div>
                  <div className="stat"><span>Tama√±o (N):</span><strong>{popStats.N.toLocaleString()}</strong></div>
                </div>
              )}

              <h2 style={{marginTop:14}}>2Ô∏è‚É£ Configurar muestreo</h2>
              <div className="row">
                <label>Tama√±o muestral (n)</label>
                <input type="number" min="1" step="1" value={n} onChange={e=>setn(clampNat(e.target.value))} />
                
              </div>
              <div className="row">
                <label>N√∫mero de muestras (B)</label>
                <input type="number" min="1" step="1" value={B} onChange={e=>setB(clampNat(e.target.value))} />
                
              </div>
              <div className="row inline">
                <input id="chkWOR" type="checkbox" checked={withoutReplacement} onChange={e=>setWithoutReplacement(e.target.checked)} />
                <label htmlFor="chkWOR" style={{margin:0}}>Muestrear <strong>sin</strong> reemplazo (aplica FPC)</label>
              </div>
              <div className="row inline">
                <input id="chkTheo" type="checkbox" checked={showTheo} onChange={e=>setShowTheo(e.target.checked)} />
                <label htmlFor="chkTheo" style={{margin:0}}>Mostrar normal te√≥rica</label>
              </div>
              <div className="row inline indent">
                <input id="chkSampleParams" type="checkbox" disabled={!xbarStats} checked={useSampleParams} onChange={e=>setUseSampleParams(e.target.checked)} />
                <label htmlFor="chkSampleParams" style={{margin:0}}>Usar estimaci√≥n muestral (xÃÑ, sd[xÃÑ])</label>
              </div>
              <div className="row inline">
                <input id="chkOrder" type="checkbox" disabled={!sampleData || sampleData.length === 0} checked={orderByValue} onChange={e=>setOrderByValue(e.target.checked)} />
                <label htmlFor="chkOrder" style={{margin:0}}>üìà Ordenar muestras por valor del promedio</label>
              </div>
              <div className="row inline">
                <input id="chkProcess" type="checkbox" disabled={!sampleData || sampleData.length === 0 || B > 100} checked={showSamplingProcess} onChange={e=>setShowSamplingProcess(e.target.checked)} />
                <label htmlFor="chkProcess" style={{margin:0}}>üéØ Mostrar proceso de muestreo {B > 100 ? '(deshabilitado para B > 100)' : ''}</label>
              </div>
              <div className="row inline indent">
                <input id="chkMeans" type="checkbox" disabled={!showSamplingProcess || !sampleData || sampleData.length === 0} checked={showMeans} onChange={e=>setShowMeans(e.target.checked)} />
                <label htmlFor="chkMeans" style={{margin:0}}>üî¥ Mostrar promedios (puntos rojos)</label>
              </div>

              <button className="btn success" onClick={handleSample} disabled={!popStats || busy}>üìà Tomar muestras</button>
              <button className="btn danger" onClick={handleClear} disabled={xbar.length===0 || busy}>üóëÔ∏è Limpiar muestras</button>

              <div className="progress" style={{display: busy || (progress>0 && progress<B) ? 'block' : 'none'}}>
                {busy ? `Tomando muestras‚Ä¶ ${progress}/${B}` : null}
              </div>

              {xbarStats && (
                <div className="stats">
                  <h3>üìà Estad√≠sticas de medias muestrales</h3>
                  <div className="stat"><span>Media de xÃÑ (Œº_xÃÑ):</span><strong>{xbarStats.mean.toFixed(2)}</strong></div>
                  <div className="stat"><span>Error est√°ndar emp√≠rico (sd[xÃÑ]):</span><strong>{xbarStats.sd.toFixed(2)}</strong></div>
                  {xbarStats.seTheo!=null && (
                    <div className="stat"><span>Error est√°ndar te√≥rico:</span><strong>{xbarStats.seTheo.toFixed(2)}</strong></div>
                  )}
                </div>
              )}

              <div className="info">üí° <strong>TLC:</strong> A medida que n crece, la distribuci√≥n de <em>xÃÑ</em> se aproxima a una normal con media Œº y desv√≠o œÉ/‚àön; si muestreamos <em>sin</em> reemplazo, se multiplica adem√°s por la FPC ‚àö((N‚àín)/(N‚àí1)).</div>

              <div className="tests">
                <strong>Self-tests:</strong> abr√≠ la consola para ver <code>‚úì</code>/<code>‚úó</code>.
              </div>
            </div>
            <div className={`charts ${showSamplingProcess ? 'three-charts' : 'two-charts'}`}>
              <div className="chart-card">
                <h3>üìä Histograma de la poblaci√≥n</h3>
                <div className="chart-wrap"><canvas ref={popChartRef}></canvas></div>
              </div>
              {showSamplingProcess && (
                <div className="chart-card">
                  <h3>üéØ Proceso de muestreo</h3>
                  <div className="chart-wrap"><canvas ref={samplesChartRef}></canvas></div>
                </div>
              )}
              <div className="chart-card">
                <h3>üìà Histograma de medias muestrales</h3>
                <div className="chart-wrap"><canvas ref={smChartRef}></canvas></div>
              </div>
            </div>
            <div style={{gridColumn:'1 / -1', marginTop: 16, textAlign:'center', color:'#6b7280', fontSize:12}}>
              <strong>Sergio Ruminot - 2025</strong><br/>
              Departamento de Estad√≠stica - FAEA<br/>
              Universidad Nacional del Comahue
            </div>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>